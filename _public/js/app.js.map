{"version":3,"file":"_public/js/app.js","sources":["app/app.js","app/scripts/Daemon/Bootstrap.js","app/scripts/Daemon/Manager.js","app/scripts/Global/AppCtrl.js","app/scripts/Global/InitializeCtrl.js","app/scripts/Global/Message.js","app/scripts/Global/NeDBConnector.js","app/scripts/Wallet/addresses/AddressesCtrl.js","app/scripts/Wallet/core/Wallet.js","app/scripts/Wallet/dashboard/DashboardCtrl.js","app/scripts/Wallet/receive/ReceiveCtrl.js","app/scripts/Wallet/send/SendCtrl.js","app/scripts/Wallet/transactions/TransactionsCtrl.js","app/scripts/directives.js","app/scripts/filters.js","app/scripts/services.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CCrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CClSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CCPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CCzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CCdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CCzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CCtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CCPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CCRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;CCRA;AACA;AACA;AACA;AACA","sourcesContent":["'use strict';\n\nvar App = angular.module('app', ['ngCookies', 'ngResource', 'ngRoute', 'ngAnimate', 'app.wallet', 'app.global', 'app.daemon', 'app.directives', 'app.filters', 'app.services', 'partials']);\n\n// Setting up namespaces for the applications\nApp.Wallet = angular.module('app.wallet', []);\nApp.Global = angular.module('app.global', []);\nApp.Daemon = angular.module('app.daemon', []);\n\nApp.config([\n    '$routeProvider', '$locationProvider', function ($routeProvider, $locationProvider, config) {\n        $routeProvider\n            .when('/dashboard', { controller: 'DashboardCtrl', templateUrl: '/partials/dashboard.html'})\n            .when('/send', { controller: 'SendCtrl', templateUrl: '/partials/send.html' })\n            .when('/receive', { controller: 'ReceiveCtrl', templateUrl: '/partials/receive.html' })\n            .when('/transactions', { controller: 'TransactionsCtrl', templateUrl: '/partials/transactions.html' })\n            .when('/addresses', { controller: 'AddressesCtrl', templateUrl: '/partials/addresses.html' })\n\n            .when('/initialize', { controller: 'InitializeCtrl', templateUrl: '/partials/initialize.html' })\n            .otherwise({ redirectTo: '/dashboard' });\n\n        return $locationProvider.html5Mode(false);\n    }\n]);\n\nApp.run(['$rootScope', '$route', '$location', 'DaemonManager', function ($rootScope, $route, $location, DaemonManager) {\n\n    $rootScope.$on(\"$routeChangeStart\", function (event, next) {\n        if (next != undefined && next.$$route != undefined) {\n\n            if (!DaemonManager.isRunning()) {\n                $location.path('/initialize');\n            }\n\n        }\n    });\n\n}]);","App.Daemon.Bootstrap = (function () {\n\n    /**\n     * The Daemon Bootstrapper initializes a local daemon for use with the wallet. It will return a\n     * promise that resolves to a standard Message object indicating if it succeeded or not.\n     *\n     * @param $q\n     * @param $timeout\n     * @param $rootScope\n     * @constructor\n     */\n\n    function Bootstrap ($q, $timeout, $rootScope) {\n\n        this.debugEnabled = true;\n\n        this.$q = $q;\n        this.$timeout = $timeout;\n        this.$rootScope = $rootScope;\n\n        this.os = require('os');\n        this.fs = require('fs');\n        this.daemon = null;\n        this.deferred = $q.defer();\n        this.daemonFilePath = null;\n        this.gui = require('nw.gui');\n        this.win = this.gui.Window.get();\n        this.childProcess = require('child_process');\n\n        this.dbSettings = App.Global.NeDB.collection('settings');\n\n        this.daemonMap = {\n            'linux': {\n                'x32': 'daemons/reddcoind-linux32',\n                'x64': 'daemons/reddcoind-linux64',\n                'default': 'daemons/reddcoind-linux32'\n            },\n            'win32': {\n                'x32': 'daemons/reddcoind-win32',\n                'default': 'daemons/reddcoind-win32'\n            },\n            'darwin': {\n                'x32': 'daemons/reddcoind-mac32',\n                'x64': 'daemons/reddcoind-mac32',\n                'default': 'daemons/reddcoind-mac-32'\n            }\n        };\n    }\n\n    Bootstrap.prototype = {\n\n        /**\n         * # Main Function\n         *\n         * Start the local daemon\n         */\n        startLocal: function () {\n\n            var self = this;\n            var message = this.runPreChecks();\n\n            if (!message.result) {\n                this.debug(message.message);\n\n                this.deferred.reject(message);\n                self.$rootScope.$broadcast('daemon.bootstrapped', message);\n\n                return this.deferred.promise;\n            }\n\n            this.runOsSpecificTasks();\n\n            this.killExistingPid();\n\n            this.spawnDaemon();\n\n            this.setupDaemonListeners()\n\n            // We will do a timeout function to give the daemon change to initialize..\n            this.$timeout(function() {\n                var message = new App.Global.Message(true, 0, 'Daemon Ready');\n\n                self.$rootScope.$broadcast('daemon.bootstrapped', message);\n                self.deferred.resolve(message);\n\n                self.debug(message);\n            }, 1000);\n\n            // Setup an internal to emit a notification of a 'block' as want the wallet to stay up to date even\n            // if no actions are performed. If the wallet is connected to an already started external daemon\n            // then we wont receive its alerted notifications.\n            // This wallet is not designed to connect to daemons outside of a local network as it may be sluggish.\n            setInterval(function() {\n                self.$rootScope.$broadcast('daemon.notifications.block');\n            }, 15 * 1000);\n\n            return this.deferred.promise;\n        },\n\n        /**\n         * The daemon outputs various data, setup listeners to catch this fire and off events.\n         */\n        setupDaemonListeners: function () {\n            var self = this;\n\n            this.daemon.stdout.on('data', function (data) {\n                self.debug(\"Received daemon data from 'stdout'\");\n                self.$rootScope.$emit('daemon.notifications.block');\n            });\n\n            this.daemon.stderr.on('error', function (data) {\n                self.debug(\"Received daemon error from 'stderr'\");\n            });\n\n            // When the main window (the one starting this) is closed, kill the daemon.\n            this.win.on('close', function() {\n                self.daemon.kill('SIGTERM', function() {\n                    self.debug(\"Daemon killed\");\n                });\n\n                this.close(true);\n            });\n\n            this.daemon.on('close', function (data) {\n                self.debug(\"Daemon child process has ended.\");\n            });\n        },\n\n        /**\n         * Spawns the daemon.\n         */\n        spawnDaemon: function() {\n            this.daemon = this.childProcess.spawn(this.daemonFilePath, [\n                '-alertnotify=echo \"ALERT:%s\"',\n                '-walletnotify=echo \"WALLET:%s\"'\n                //'-blocknotify=echo \"BLOCK:%s\"'\n            ]);\n\n            this.saveDaemonPid();\n        },\n\n        /**\n         * Checks that the daemon can run on the OS, initialises the path to the daemon & makes sure\n         * the daemon actually exists.\n         *\n         * @returns {App.Global.Message}\n         */\n        runPreChecks: function () {\n            if (!this.hasValidDaemon()) {\n                return new App.Global.Message(\n                    false, 1, 'This operating system does not support running the Reddcoin daemon.'\n                );\n            }\n\n            this.initializeFilePath();\n\n            if (!this.fs.existsSync(this.daemonFilePath)) {\n                var platform = this.os.platform() + ' ' + this.os.arch();\n                return new App.Global.Message(\n                    false, 2, 'Cannot find the daemon for this operating system: ' + platform\n                );\n            }\n\n            return new App.Global.Message(true, 0, 'Pre-checks complete');\n        },\n\n        /**\n         * Runs commands based on the OS, on *nix you need the chmod the daemon just in case.\n         */\n        runOsSpecificTasks: function() {\n            if (!this.isWindows()) {\n                this.childProcess.exec('chmod 777 ' + this.daemonFilePath);\n            }\n        },\n\n        /**\n         * If a platform is found, the daemon has to have a workable version on the OS.\n         *\n         * @returns {boolean}\n         */\n        hasValidDaemon: function() {\n            var platform = this.os.platform();\n            return this.daemonMap[platform] !== undefined;\n        },\n\n        /**\n         * Gets the correct path to the daemon.\n         */\n        initializeFilePath: function() {\n            var osArch = this.os.arch();\n            var osPlatform = this.os.platform();\n\n            var platform = this.daemonMap[osPlatform];\n\n            if (platform !== undefined) {\n                // There is a platform, which means we can definitely run the default...\n                if (platform[osArch] == undefined) {\n                    // Default architecture.. (likely will be 32bit)\n                    this.daemonFilePath = platform['default'];\n                } else {\n                    this.daemonFilePath = platform[osArch];\n                }\n            }\n        },\n\n        /**\n         * Save the current daemon process ID to the database, this is so we\n         * can kill any daemon upon restart if it didn't get closed.\n         *\n         * @param {function=} callback\n         */\n        saveDaemonPid: function(callback) {\n            var self = this;\n            this.dbSettings.findOne({ \"type\": \"daemon\" }, function (err, doc) {\n                if (doc == null) {\n                    self.dbSettings.insert({\n                        type: 'daemon',\n                        pid: self.daemon.pid\n                    }, function() {\n                        typeof callback === 'function' && callback();\n                    });\n                } else {\n                    doc.pid = self.daemon.pid;\n                    self.dbSettings.update({_id:doc._id}, { $set: doc }, function() {\n                        typeof callback === 'function' && callback();\n                    });\n                }\n            });\n        },\n\n        /**\n         * Retrieves the previously saved process ID and tries to kill it, it then deletes\n         * the record from the DB.\n         *\n         * @param {function=} callback\n         */\n        killExistingPid: function(callback) {\n            var self = this;\n            this.dbSettings.findOne({ \"type\": \"daemon\" }, function (err, doc) {\n                if (doc == null) return;\n\n                try {\n                    process.kill(doc.pid);\n\n                    self.dbSettings.remove({\"type\": \"daemon\"}, {});\n\n                    typeof callback === 'function' && callback(true);\n                } catch (error) {\n                    self.debug(error);\n\n                    typeof callback === 'function' && callback(false);\n                }\n            });\n        },\n\n        /**\n         * Returns the promise that is resolved when the daemon is initialized.\n         *\n         * @returns {promise|defer.promise|Promise.promise|Q.promise}\n         */\n        getPromise: function() {\n            return this.deferred.promise;\n        },\n\n        /**\n         * Determines whether the current platform is windows or not.\n         *\n         * @returns {boolean}\n         */\n        isWindows: function() {\n            return this.os.platform() === 'win32';\n        },\n\n        /**\n         * If debugging is enabled, it will log it to the console.\n         *\n         * @param data\n         */\n        debug: function (data) {\n            if (this.debugEnabled) {\n                console.log(data);\n            }\n        }\n\n    };\n\n\n    return Bootstrap;\n\n}());\n","App.Daemon.factory('DaemonManager',\n    [\n        '$q',\n        '$timeout',\n        '$rootScope',\n        function($q, $timeout, $rootScope) {\n\n            function Manager() {\n\n                this.running = false;\n\n                this.bootstrap = new App.Daemon.Bootstrap($q, $timeout, $rootScope);\n\n                this.client = require('node-reddcoin')({\n                    user: 'user',\n                    pass: 'password'\n                });\n\n                this.initialize();\n\n            }\n\n            Manager.prototype = {\n\n                initialize: function() {\n                    var self = this;\n\n                    /**\n                     * This promise callback will set the running bool once the bootstrap has completed.\n                     *\n                     * @param {App.Global.Message} message\n                     */\n                    this.bootstrap.getPromise().then(function(message) {\n                        self.running = message.result;\n\n                        return message;\n                    });\n\n                },\n\n                getClient: function () {\n                    return this.client;\n                },\n\n                getBootstrap: function() {\n                    return this.bootstrap;\n                },\n\n                isRunning: function() {\n                    return this.running;\n                }\n\n            };\n\n            return new Manager();\n\n        }\n\n    ]\n);","App.Global.controller(\n    'AppCtrl',\n    [\n        '$scope', '$location', '$resource', '$rootScope', 'DaemonManager', 'wallet',\n        function($scope, $location, $resource, $rootScope, DaemonManager, wallet) {\n\n            $scope.wallet = wallet;\n\n            $scope.daemon = {\n                running: false\n            };\n\n            $rootScope.$on('daemon.bootstrapped', function(event, message) {\n                $scope.daemon.running = message.result;\n            });\n\n            $scope.$location = $location;\n            $scope.$watch('$location.path()', function(path) {\n                return $scope.activeNavId = path || '/';\n            });\n\n            return $scope.getClass = function(id) {\n                if ($scope.activeNavId.substring(0, id.length) === id) {\n                    return 'active';\n                } else {\n                    return '';\n                }\n            };\n\n        }\n    ]\n);","App.Global.controller(\n    'InitializeCtrl',\n    [\n        '$scope', '$location', '$resource', '$rootScope', 'DaemonManager', 'wallet',\n        function($scope, $location, $resource, $rootScope, DaemonManager, wallet) {\n\n            var bootstrap = DaemonManager.getBootstrap();\n\n            $scope.loadingStatus = 'Loading...';\n\n            $scope.displayError = function (title, message) {\n                $scope.loadingStatus = title;\n                $scope.loadingStatusError = message;\n            };\n\n            $scope.initialize = function() {\n                wallet.initialize();\n\n                var promise = bootstrap.startLocal();\n\n                promise.then(function(message) {\n                    if (message.result) {\n                        $location.path('/dashboard');\n                    } else {\n                        $scope.displayError('Uh Oh!', message.message);\n                    }\n                });\n\n            };\n\n            $scope.initialize();\n\n        }\n    ]\n);","App.Global.Message = (function () {\n\n    /**\n     * A rigid message object used to pass data around.\n     *\n     * @param result\n     * @param message\n     * @param code\n     * @param extra\n     * @constructor\n     */\n    function Message (result, code, message, extra) {\n        this.result = result;\n        this.message = message;\n        this.code = code;\n\n        if (extra != undefined) {\n            for (var key in extra) {\n                if (!extra.hasOwnProperty(key)) continue;\n                this[key] = extra[key];\n            }\n        }\n    }\n\n    Message.prototype = {\n\n\n\n    };\n\n    return Message;\n\n}());\n\n/*\n Error Codes\n ===========\n\n 1 : The operating system running the application does not have a supported reddcoind daemon.\n 2 : The deamon for the selected operating system cannot be find, most likely a file path issue or\n     was failed to be bundled with the wallet.\n 3 :\n\n\n*/\n","var neDbInstance = null;\n\nApp.Global.NeDB = (function () {\n\n    var NeDB = function () {\n\n    };\n\n    NeDB.prototype = {\n\n        get: function () {\n\n            var NeDB, datapath, e, store;\n            try {\n                NeDB = require(\"nedb\");\n                datapath = require('nw.gui').App.dataPath + \"/nedb\";\n                store = {\n                    collection: function (name) {\n                        return new NeDB({\n                            filename: \"app/nedb/\" + name,\n                            autoload: true\n                        });\n                    }\n                };\n                return store;\n            } catch (_error) {\n                e = _error;\n                if (e.code === \"MODULE_NOT_FOUND\") {\n                    return console.error(\"NeDB not found. Try `npm install nedb --save` inside of `/app/assets`.\");\n                } else {\n                    return console.error(e);\n                }\n            }\n        }\n\n    };\n\n    if (neDbInstance == null) {\n        neDbInstance = new NeDB().get();\n    }\n\n    return neDbInstance;\n\n}());","App.Wallet.controller(\n    'AddressesCtrl',\n    [\n        '$scope', function($scope) {\n            return $scope;\n        }\n    ]\n);","App.Wallet.factory('wallet',\n    [\n        '$q',\n        '$timeout',\n        '$rootScope',\n        'DaemonManager',\n        function ($q, $timeout, $rootScope, DaemonManager) {\n\n            var client = DaemonManager.getClient();\n\n            var WalletModel = function () {\n\n                this.info = {\n                    \"version\": \"\",\n                    \"protocolversion\": \"\",\n                    \"walletversion\": \"\",\n                    \"balance\": 0,\n                    \"blocks\": 0,\n                    \"timeoffset\": 0,\n                    \"connections\": 0,\n                    \"proxy\": \"\",\n                    \"difficulty\": 0,\n                    \"testnet\": false,\n                    \"keypoololdest\": 0,\n                    \"keypoolsize\": 0,\n                    \"paytxfee\": 0,\n                    \"mininput\": 0.00,\n                    \"errors\": \"\"\n                };\n\n                this.accounts = [\n\n                ];\n\n            };\n\n            WalletModel.prototype = {\n\n                send: function(data) {\n                    var self = this;\n\n                    client.exec('settxfee', data.fee, function(err, info) {\n                        if (info || info == 'true') {\n                            client.exec('sendtoaddress', data.address, parseFloat(data.amount), data.payerComment, data.payeeComment, function(err, info) {\n                                if (err == null) {\n                                    console.log(\"Transaction Complete\");\n                                } else {\n                                    console.log(err);\n                                }\n                            });\n                        }\n                    });\n\n                },\n\n                updateInfo: function() {\n                    var self = this;\n                    client.exec('getinfo', function (err, info) {\n                        if (err == null) {\n                            self.info = info;\n                            $rootScope.$apply();\n                        }\n                    });\n                },\n\n                updateAccounts: function() {\n\n                    var async = require('async');\n                    var self = this;\n\n                    client.exec('listaccounts', function (err, accountList) {\n                        if (err == null) {\n\n                            var accounts = [];\n\n                            for (var key in accountList) {\n                                if (!accountList.hasOwnProperty(key)) continue;\n\n                                (function (key) {\n                                    async.series(\n                                        {\n                                            one: function(callback) {\n\n                                                var newAccount = {\n                                                    label: key,\n                                                    balance: accountList[key],\n                                                    address: ''\n                                                };\n\n                                                accounts.push(newAccount);\n\n                                                client.exec('getaccountaddress', newAccount.label, function(err, address) {\n                                                    if (err != null) {\n                                                        console.log(err);\n                                                        callback(false);\n                                                    } else {\n                                                        newAccount.address = address;\n                                                        callback(true);\n                                                    }\n                                                });\n\n                                            }\n                                        },\n                                        function (err, results) {\n                                            self.accounts = accounts;\n                                            $rootScope.$apply();\n                                        }\n                                    )\n                                }(key));\n                            }\n                        }\n                    });\n                },\n\n                initialize: function() {\n                    var self = this;\n\n                    $rootScope.$on('daemon.bootstrapped', function (event, message) {\n                        if (message.result) {\n                            self.updateInfo();\n                            self.updateAccounts();\n                        }\n                    });\n\n                    $rootScope.$on('daemon.notifications.block', function () {\n                        self.updateInfo();\n                        self.updateAccounts();\n                    });\n\n                }\n\n            };\n\n            return new WalletModel();\n        }\n\n    ]\n);","App.Wallet.controller(\n    'DashboardCtrl',\n    [\n        '$scope',\n        'DaemonManager',\n        'wallet',\n        function ($scope, daemon, wallet) {\n\n            $scope.wallet = wallet;\n\n\n\n        }\n    ]\n);","App.Wallet.controller(\n    'ReceiveCtrl',\n    [\n        '$scope',\n        'DaemonManager',\n        'wallet',\n        function ($scope, daemon, wallet) {\n\n            $scope.wallet = wallet;\n\n            $scope.copy = function ($index) {\n\n                // Load native UI library\n                var gui = require('nw.gui');\n\n                // We can not create a clipboard, we have to receive the system clipboard\n                var clipboard = gui.Clipboard.get();\n\n                // Set the address..\n                clipboard.set($scope.wallet.accounts[$index].address);\n\n            };\n\n        }\n    ]\n);","App.Wallet.controller(\n    'SendCtrl',\n    [\n        '$scope',\n        'DaemonManager',\n        'wallet',\n        function ($scope, daemon, wallet) {\n\n            $scope.wallet = wallet;\n\n            $scope.send = {\n                amount: 1,\n                address: 'Rer7K4AwRhUYshzzPeamRkC9cV7M6BSz3P',\n                payerComment: '',\n                payeeComment: '',\n                fee: 0.001\n            };\n\n            $scope.meta = {\n                totalAmount: 0\n            };\n\n            $scope.confirmSend = function() {\n                wallet.send($scope.send);\n            };\n\n            $scope.updateMetaTotal = function() {\n                var result = parseFloat($scope.send.amount) + parseFloat($scope.send.fee);\n                if (result == null || result == undefined || isNaN(result)) {\n                    result = \"Invalid Amount\";\n                }\n                $scope.meta.totalAmount = result;\n            };\n\n            $scope.updateMetaTotal();\n\n        }\n    ]\n);","App.Wallet.controller(\n    'TransactionsCtrl',\n    [\n        '$scope', function($scope) {\n            return $scope;\n        }\n    ]\n);","/* Directives*/\n\nangular.module('app.directives', ['app.services']).directive('appVersion', [\n    'version', function(version) {\n        return function(scope, elm, attrs) {\n            return elm.text(version);\n        };\n    }\n]);","/* Filters*/\n\nangular.module('app.filters', []).filter('interpolate', [\n    'version', function(version) {\n        return function(text) {\n            return String(text).replace(/\\%VERSION\\%/mg, version);\n        };\n    }\n]);","/* Sevices*/\n\nangular.module('app.services', []).factory('version', function() {\n    return \"0.1\";\n});"]}